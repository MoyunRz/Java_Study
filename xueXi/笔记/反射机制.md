## Reflection (反射) 概述

- 它被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API取得任何类的内部信息，并能做出操作任意对象的内部属性及方法

- 加载完类后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。
我们可以通过这个对象看到类的内部结构。这就像是一面镜子，有过镜子我们可以看到类的结构，我们对此称之为：反射

**方式的比较：**
           
        正常方式： 引入需要的"包类"名称 --> 通过new实例化 -->取得实例化对象
        
        反射方式： 实例化对象 --> getClass()方法 --> 得到完整的"包类"名称
      

## 反射功能

- 在运行时判断任意一个对象所属的类

- 在运行时构造任意一个类的对象

- 在运行时判断任意一个类所具有的成员变量和方法

- 在运行时调用任意一个对象的成员变量和方法

- 在运行时处理注解

- 生成动态代理


## 问题

- 通过直接new的方式或者反射的方式都可以调用公共的结构，开发中到底用哪个？

        建议用new的方式，原因是代码量少且直接。当类的方法、结构确定时，就用new
        反射特征是：动态性，当类的结构不确定时，用反射进行修改 

- 反射机制与面向对象中的封装性是不是矛盾了？如何看待两个技术？

        不矛盾。封装建议调用公共方法，反射机制增加了灵活和应变，当有需要时，程序员可以通过反射调用封装对象的私有方法和变量 

## java.lang.Class类的理解

- 加载过程：
    
        程序经过javac.exe命令后，会生成一个或者多个字节码文件（.class结尾），接着我们使用java.exe命令对某个字节码进行解释运行。
        相当于将某个字节码加载到内存中。此过程称为类的加载。加载到内存中的类，我们称之为运行时类，此运行时类，就作为Class的一个实例。
 
- 加载到内存中的运行时类，会缓存一定的时间。在此时间内，我们可以通过不同的方式来获取此运行时类
   
## 获取Class的实例的方式

```

public void test4() throws ClassNotFoundException {
        // 方式一：调用运行时类的属性：.class
        Class clas=Person.class;
        System.out.println(clas);
        
        // 方式二：通过运行时类的对象，调用getClass()
        Person p1 = new Person();
        Class clas2=p1.getClass();
        System.out.println(clas2);
        
        // 方式三：调用Class的静态方法：forname(String classPath)
        Class clas3 = Class.forName("com.Person.Person");
        System.out.println(clas3);
        
}

```


     
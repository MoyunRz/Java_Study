## Reflection (反射) 概述

- 它被视为动态语言的关键，反射机制允许程序在执行期借助Reflection API取得任何类的内部信息，并能做出操作任意对象的内部属性及方法

- 加载完类后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。
我们可以通过这个对象看到类的内部结构。这就像是一面镜子，有过镜子我们可以看到类的结构，我们对此称之为：反射

**方式的比较：**
           
        正常方式： 引入需要的"包类"名称 --> 通过new实例化 -->取得实例化对象
        
        反射方式： 实例化对象 --> getClass()方法 --> 得到完整的"包类"名称
      

## 反射功能

- 在运行时判断任意一个对象所属的类

- 在运行时构造任意一个类的对象

- 在运行时判断任意一个类所具有的成员变量和方法

- 在运行时调用任意一个对象的成员变量和方法

- 在运行时处理注解

- 生成动态代理


## 问题

- 通过直接new的方式或者反射的方式都可以调用公共的结构，开发中到底用哪个？

        建议用new的方式，原因是代码量少且直接。当类的方法、结构确定时，就用new
        反射特征是：动态性，当类的结构不确定时，用反射进行修改 

- 反射机制与面向对象中的封装性是不是矛盾了？如何看待两个技术？

        不矛盾。封装建议调用公共方法，反射机制增加了灵活和应变，当有需要时，程序员可以通过反射调用封装对象的私有方法和变量      